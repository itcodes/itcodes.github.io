<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>优弧的博客</title>
  
  <subtitle>但行好事，莫问前程</subtitle>
  <link href="https://itcodes.github.io/atom.xml" rel="self"/>
  
  <link href="https://itcodes.github.io/"/>
  <updated>2025-09-07T16:26:41.667Z</updated>
  <id>https://itcodes.github.io/</id>
  
  <author>
    <name>优弧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>养驴的经验</title>
    <link href="https://itcodes.github.io/4898782c31d1/"/>
    <id>https://itcodes.github.io/4898782c31d1/</id>
    <published>2025-05-11T15:34:31.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>不能让他看清楚方向，干活的时候盖住眼睛</p></li><li><p>不能让他知道主人杀死过多少头驴</p></li><li><p>换一个更好的磨盘，让他在别的驴面前有优越感</p></li><li><p>让他不停地干活，没有空闲时间听外面的声音</p></li><li><p>告诉他 别人家的驴不如咱家过得好</p></li><li><p>对不听话的驴大刑侍候，打差的绩效，实在不行做成驴火</p></li><li><p>树立典型 对表现好的适当多给一些饲料</p></li><li><p>从小培养它的爱家信念 让他死心塌地拉磨</p></li><li><p>买一些品质，材质更好的鞭子，让驴们相互比较，推荐给驴友的主人也买</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不能让他看清楚方向，干活的时候盖住眼睛&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不能让他知道主人杀死过多少头驴&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;换一个更好的磨盘，让他在别的驴面前有优越感&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;让他不停地干活，没有空闲时间听外面的声</summary>
      
    
    
    
    <category term="职场思考" scheme="https://itcodes.github.io/categories/%E8%81%8C%E5%9C%BA%E6%80%9D%E8%80%83/"/>
    
    
    <category term="弧言弧语" scheme="https://itcodes.github.io/tags/%E5%BC%A7%E8%A8%80%E5%BC%A7%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>保持对工作的一点责任感</title>
    <link href="https://itcodes.github.io/47f80ddb16a9/"/>
    <id>https://itcodes.github.io/47f80ddb16a9/</id>
    <published>2023-03-28T05:03:17.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<p>人啊，总把自己的无能归结于工具不行。</p><p>比如掘金的奖品发货问题，用户总是每天反馈。为什么会有这么多反馈？负责的人每天都在做什么？</p><p>1、你的活动结束后，有没有按照承诺的时间发出奖品。如果不能，为什么不说？</p><p>2、如果是部分发货，为什么不跟未发货的同学解释？</p><p>3、如果用户没有按时填写问卷，有没有应对方案。有没有可能做的更有温度一点？</p><p>4、每次活动到处嗷嗷嗷，实际最后啥也不是，为什么自己不反思？</p><p>别找那么多理由，你特么是运营，这都干不好？你还能干啥？</p><p>如果你觉得好难做哦，那可能难的不是这些事本身，难的是改变自己的一些旧行为或习惯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人啊，总把自己的无能归结于工具不行。&lt;/p&gt;
&lt;p&gt;比如掘金的奖品发货问题，用户总是每天反馈。为什么会有这么多反馈？负责的人每天都在做什么？&lt;/p&gt;
&lt;p&gt;1、你的活动结束后，有没有按照承诺的时间发出奖品。如果不能，为什么不说？&lt;/p&gt;
&lt;p&gt;2、如果是部分发货，为什么不跟</summary>
      
    
    
    
    <category term="职场思考" scheme="https://itcodes.github.io/categories/%E8%81%8C%E5%9C%BA%E6%80%9D%E8%80%83/"/>
    
    
    <category term="弧言弧语" scheme="https://itcodes.github.io/tags/%E5%BC%A7%E8%A8%80%E5%BC%A7%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>新必应无法加入等待队列且一直出错的解决方案</title>
    <link href="https://itcodes.github.io/096fdba65075/"/>
    <id>https://itcodes.github.io/096fdba65075/</id>
    <published>2023-03-26T22:50:44.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<p>大家伙，我是优弧，我这次又来为大家解疑答惑了，这次解决的问题是new bing 相关的，如果我能帮助到你，麻烦你帮我点个赞。感谢。</p><p>new bing 的申请，没啥好说的，简单直接，跟 Notion AI 一样，最好全局一下，进入网址<a href="https://www.bing.com/new">www.bing.com/new</a>，加入等待，等通知邮件。</p><p>但是有大部分同学，应该跟我一样，自己用了多年的主账号，不管怎么样，按照网上说的各种法子尝试都是不会成功。</p><p>如下图所示：点击“加入等待列表”但一直提示“出错了，请重试”，</p><p><img src="https://images.unsplash.com/photo-1563986768609-322da13575f3?ixlib=rb-4.0.3&auto=format&fit=crop&w=1280&q=80" alt="bing-error-screenshot"><br>无奈之下，换了一个新账号尝试，如果你是一个注册的新账号，new bing一定会成功加入 waitling list。</p><p><img src="https://images.unsplash.com/photo-1551288049-bebda4e38f71?ixlib=rb-4.0.3&auto=format&fit=crop&w=1280&q=80" alt="bing-success-screenshot"></p><p>作为微软 office 365 多年的订阅用户，微软全系列产品 msdn订阅 的正版用户。在关键时候P 用没有。在 msdn 社区反馈之后，接到专家的一个电话，告知解决方案。</p><p><img src="https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d?ixlib=rb-4.0.3&auto=format&fit=crop&w=1280&q=80" alt="microsoft-support-screenshot"></p><hr><h4 id="之前用过的解决方案："><a href="#之前用过的解决方案：" class="headerlink" title="之前用过的解决方案："></a>之前用过的解决方案：</h4><ul><li>什么改 dns 都是瞎扯。</li><li>有人说可能跟Microsoft rewards 有关系，我也清理了全部rewards，仍然出现同样错误。在手机上面尝试加入等待列表，错误一样。</li></ul><h4 id="真正的解决方案："><a href="#真正的解决方案：" class="headerlink" title="真正的解决方案："></a>真正的解决方案：</h4><p>最终跟专家确认，new bing 的体验确实受 Microsoft rewards 影响，但是清理全部 rewards 没什么用，可以通过：<a href="https://rewards.bing.com/optout">https://rewards.bing.com/optout</a> 退出rewards计划，之后再通过：<a href="https://rewards.bing.com/">https://rewards.bing.com/</a>加入rewards； 之后再点击加入waitling list 候补就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家伙，我是优弧，我这次又来为大家解疑答惑了，这次解决的问题是new bing 相关的，如果我能帮助到你，麻烦你帮我点个赞。感谢。&lt;/p&gt;
&lt;p&gt;new bing 的申请，没啥好说的，简单直接，跟 Notion AI 一样，最好全局一下，进入网址&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="人工智能" scheme="https://itcodes.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="New Bing" scheme="https://itcodes.github.io/tags/New-Bing/"/>
    
  </entry>
  
  <entry>
    <title>保持认知的开放性</title>
    <link href="https://itcodes.github.io/f0faddf60cbc/"/>
    <id>https://itcodes.github.io/f0faddf60cbc/</id>
    <published>2023-03-26T22:33:44.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<p>大脑喜欢确定性的东西，对非确定性有着天然的排斥，所以在遇到一个模糊的问题时，人们就会产生给问题找出一个明确答案的欲望，这种心理机制叫做认知闭合。为了尽快排解不确定性忧虑，往往会快速给一个问题下结论，有了这个结论，就可以达到一种认知闭合的状态。</p><p>工作中很容易犯下这样的错误，在不假思索或者证据不足的情况下，对问题进行主观性判断，并给出一个偏主观的结论，接着开始拒绝新的思想、经验或观点，并对他人的意见也持怀疑态度。</p><p>保持认知的开放性，比较重要，但前提是能够感知到自己对认知闭合的倾向性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大脑喜欢确定性的东西，对非确定性有着天然的排斥，所以在遇到一个模糊的问题时，人们就会产生给问题找出一个明确答案的欲望，这种心理机制叫做认知闭合。为了尽快排解不确定性忧虑，往往会快速给一个问题下结论，有了这个结论，就可以达到一种认知闭合的状态。&lt;/p&gt;
&lt;p&gt;工作中很容易犯下</summary>
      
    
    
    
    <category term="职场思考" scheme="https://itcodes.github.io/categories/%E8%81%8C%E5%9C%BA%E6%80%9D%E8%80%83/"/>
    
    
    <category term="弧言弧语" scheme="https://itcodes.github.io/tags/%E5%BC%A7%E8%A8%80%E5%BC%A7%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>偶感</title>
    <link href="https://itcodes.github.io/d07c65d6ef95/"/>
    <id>https://itcodes.github.io/d07c65d6ef95/</id>
    <published>2023-02-26T16:34:31.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<p>一个不会追求宁静的人不会体会到当夜深人静时，一个人思索，一个人体会，一个人思想超越自我，超越精神的极限，神游天地，独享孤独，独享凄清，甚至独享眼泪的惬意。独营造了一个完全属于自我的世界，在这里你没有了喧嚣有的只是宁静。我喜欢在宁静中思考，思考周围的人，周围的事，思考前路，和走过的路。独是我无法或不愿面对时的一种反应，既然我的世界不该有的就让我简单些把。即使是一个人，即使是别人都不认可的一种状态，但对我而言那是一种境界，别人不可企及。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个不会追求宁静的人不会体会到当夜深人静时，一个人思索，一个人体会，一个人思想超越自我，超越精神的极限，神游天地，独享孤独，独享凄清，甚至独享眼泪的惬意。独营造了一个完全属于自我的世界，在这里你没有了喧嚣有的只是宁静。我喜欢在宁静中思考，思考周围的人，周围的事，思考前路，和</summary>
      
    
    
    
    <category term="活着" scheme="https://itcodes.github.io/categories/%E6%B4%BB%E7%9D%80/"/>
    
    
    <category term="弧言弧语" scheme="https://itcodes.github.io/tags/%E5%BC%A7%E8%A8%80%E5%BC%A7%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>3 个鲜为人知的 Bash 技巧</title>
    <link href="https://itcodes.github.io/d8c2edb4f3dc/"/>
    <id>https://itcodes.github.io/d8c2edb4f3dc/</id>
    <published>2023-02-14T09:53:43.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://medium.com/better-programming/3-uncommon-bash-tricks-that-you-should-know-c0fc988065c7">3 Uncommon Bash Tricks That You Should Know</a></li><li>原文作者：<a href="https://medium.com/@adgefficiency">Adam Green</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li></ul></blockquote><p>优秀的开发人员往往键入的内容更少 —— 这也让他们能够：</p><ul><li>更快地工作</li><li>更准确地工作</li><li>减少错误</li><li>减轻双手疲劳的压力</li></ul><p>一种减少键入的方法是恰当地使用你的命令行（通常是 Bash），<strong>而本文将要向大家介绍的内容就是 —— 3 个减少键入的 Bash 技巧。</strong></p><p>本文中介绍的 3 个 Bash 技巧是：</p><ol><li>使用 <code>&#123;a,b&#125;</code> —— 扩展参数，以避免再次键入单个命令</li><li>使用 <code>$_</code> —— 访问最后一个参数，以避免从最后一个命令中重新键入</li><li>使用 <code>^old^new</code> —— 快速更改最后一条命令的一部分</li></ol><p>所有这些技巧都与 zsh 兼容。</p><p><strong>本文输入的命令均以 <code>$</code> 开头。对于命令行解析后的代码，我将在相关代码下面以不带 <code>$</code> 的单独一行写出这句代码等同的解析后的代码。</strong></p><h2 id="a-b-拓展参数"><a href="#a-b-拓展参数" class="headerlink" title="{a,b} 拓展参数"></a><code>&#123;a,b&#125;</code> 拓展参数</h2><p>当我们在编写命令时，我们常会重复输入同一个命令。</p><p>以更改文件后缀为例，我们一般使用的是 <code>mv</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> README.txt README.md</span><br></pre></td></tr></table></figure><p>注意到我们写了两次 README，而参数扩展就可以避免这种重复 —— 更改文件的后缀而无需输入 README 两次：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> README.&#123;txt,md&#125;</span><br><span class="line"><span class="built_in">mv</span> README.txt README.md</span><br></pre></td></tr></table></figure><p>我们使用的参数扩展为 <code>&#123;txt,md&#125;</code>，而它将会扩展为两个参数 —— <code>txt md</code>（会以空格分隔）。</p><p><strong>参数扩展会为花括号内，以逗号分割的每个元素分别创建一个参数：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &#123;1,2,3&#125;</span><br><span class="line">1 2 3</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> pre&#123;1,2,3&#125;</span><br><span class="line">pre1 pre2 pre3</span><br></pre></td></tr></table></figure><p>空元素将创建不带任何替换项的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> pre&#123;,1,2&#125;fix</span><br><span class="line">prefix pre1fix pre2fix</span><br></pre></td></tr></table></figure><p>另一个例子 —— 我们将要把 <code>data</code> 文件夹中的 <code>models</code> 文件夹重命名为 <code>ml</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> data/models data/ml</span><br></pre></td></tr></table></figure><p>我们可以使用参数扩展来节省重新输入 <code>data/</code>  的时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> data/&#123;models,ml&#125;</span><br><span class="line"><span class="built_in">mv</span> data/models data/ml</span><br></pre></td></tr></table></figure><p>我们可以使用带有数字序列的参数扩展 —— 这在创建顺序编号目录时很有用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> data&#123;0..2&#125;</span><br><span class="line"><span class="built_in">mkdir</span> data0 data1 data2</span><br></pre></td></tr></table></figure><p>我们还可以在<strong>参数内部进行参数扩展</strong> —— 例如，更改路径中的文件夹名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> models/&#123;baseline,final&#125;/data.csv</span><br><span class="line"><span class="built_in">cat</span> models/baseline/data.csv models/final/data.csv</span><br></pre></td></tr></table></figure><p>最后一个示例：在 <code>mv</code> 命令中，我们使用了 3 个参数 —— 将两个 Python 文件移动到 tests 文件夹中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> test_unit.py test_system.py tests</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>每当你在单个命令中多次键入某些内容时，参数扩展极大可能可以帮助你节省精力。</strong></p><h2 id="使用-使用访问最后一个参数"><a href="#使用-使用访问最后一个参数" class="headerlink" title="使用 $_ 使用访问最后一个参数"></a>使用 <code>$_</code> 使用访问最后一个参数</h2><p>终端由一系列命令操作构成，而我们经常在多个命令之间重用信息。</p><p>如果说我们前面的技巧，参数扩展，是用于减少在单个命令上的键入的。那么现在这个技巧则是用于减少对多个命令的键入。</p><p>以创建文件夹并将当前目录转移到其中的情况为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> temp</span><br><span class="line">$ <span class="built_in">cd</span> temp</span><br></pre></td></tr></table></figure><p>现在我们其实可以通过使用 <code>$_</code> <strong>将上个命令的参数传递过来</strong>，避免让自己重复键入同样的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> temp    </span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$_</span> </span><br><span class="line"><span class="built_in">cd</span> temp </span><br></pre></td></tr></table></figure><p>上面的代码中，我们使用了 <code>$_</code> 访问上一个命令的最后一个参数，在本例中这个参数为 <code>temp</code>。</p><p>想要重用上一个命令的最后一个参数（本例中为 <code>temp</code>）的场景其实非常普遍，以至于 Bash 会将其存储在一个特殊的变量 <code>_</code> 中。我们需要使用 <code>$</code> 前缀来访问它（与 <code>$PATH</code> 或 <code>$HOME</code> 相同）。</p><p>下面是使用 <code>$_</code> 的另一个示例 —— 移动文件并借助 <code>cat</code> 使用打印内容到 <code>STDOUT</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> main.py src/main.py </span><br><span class="line">$ <span class="built_in">cat</span> src/main.py</span><br></pre></td></tr></table></figure><p>那么现在我们该如何再次重用最后一个参数 <code>src/main.py</code>？</p><p>你可以使用以下命令重写此代码，<code>$_</code> 在第二个命令中会自动替换为 <code>src/main.py</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mv</span> main.py src/main.py </span><br><span class="line">$ <span class="built_in">cat</span> <span class="variable">$_</span></span><br><span class="line"><span class="built_in">cat</span> src/main.py</span><br></pre></td></tr></table></figure><p>使用 <code>$_</code> 意味着你不需要重写复杂的文件路径，从而不会在重新键入时出错。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><strong>每当你需要在多个命令重复键入某些内容时，使用 <code>$_</code> 可能有助于减轻疲惫的双手的压力。</strong></p><h2 id="使用-old-new-快速替换"><a href="#使用-old-new-快速替换" class="headerlink" title="使用 ^old^new 快速替换"></a>使用 <code>^old^new</code> 快速替换</h2><p>有时，我们可能在命令行管理程序中运行了一个命令，并很快意识到自己在命令中犯了一个错误。</p><p>但其实我们无需再次键入命令，我们可以使用快速替换，通过更换上一个命令中的内容来修复错误。</p><p>举个例子 —— 你希望通过 ssh 连接到服务器，并运行了命令去连接 —— 运行后才意识到用户名应该是 user 而非 ubuntu！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh ubuntu@198.compute.com</span><br></pre></td></tr></table></figure><p>你可以<strong>使用快速替换来更改所需的部分</strong>，而不必再次重新键入整个命令以在此处将 ubuntu 改为 user：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ^ubuntu^user</span><br><span class="line">ssh user@198.compute.com</span><br></pre></td></tr></table></figure><p>快速替换的格式是 <code>^old^new</code>，等效于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !!:s/old/new</span><br></pre></td></tr></table></figure><p><code>!!</code> 用于获取最后一个命令，而 <code>:s</code> 是替换的正则表达式。我想你会同意 <code>^old^new</code> 减轻了不少工作负担！</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><strong>当你写错了命令，并且命令不方便重写（例如很长），那么，使用 <code>^old^new</code> 能够极大的减轻你的麻烦。</strong></p><hr><p>感谢阅读！</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://medium.com/better-programming/3-uncommon-bash-tricks-that-you-should-know-c0fc988065c7&quot;&gt;3 Uncomm</summary>
      
    
    
    
    <category term="掘金翻译计划" scheme="https://itcodes.github.io/categories/%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="掘金翻译计划" scheme="https://itcodes.github.io/tags/%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>为什么 Websockets 难以扩展？</title>
    <link href="https://itcodes.github.io/db6667c5bbb2/"/>
    <id>https://itcodes.github.io/db6667c5bbb2/</id>
    <published>2023-02-10T06:18:31.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267">why Websockets are Hard To Scale？</a></li><li>原文作者：<a href="https://dev.to/nooptoday">nooptoday</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/article/2022/why-websockets-are-hard-to-scale.md">https://github.com/xitu/gold-miner/blob/master/article/2022/why-websockets-are-hard-to-scale.md</a></li><li>译者：<a href="https://github.com/CompetitiveLin">CompetitiveLin</a></li><li>校对者：<a href="https://github.com/CarlosChenN">CarlosChenN</a> <a href="https://github.com/Quincy-Ye">Quincy-Ye</a></li></ul></blockquote><h2 id="为什么-Websockets-难以扩展？"><a href="#为什么-Websockets-难以扩展？" class="headerlink" title="为什么 Websockets 难以扩展？"></a>为什么 Websockets 难以扩展？</h2><p>封面图片来自于 <a href="https://unsplash.com/@fabioha">法比奥</a></p><p>Websockets 提供了一个重要的特性：双向通信。这使得服务器在不需要客户机请求的情况下向客户机<strong>推送</strong>事件。</p><p>Websockets 这种<strong>双向</strong>的特性是一把双刃剑！尽管这种特性为 websockets 提供了大量的用例，但与 HTTP 服务器相比，实现一个可伸缩的 websockets 服务器要困难得多。</p><blockquote><p><em>无耻的自我推销：</em> 我认为 websockets 是 web 网页的一个重要部分并且它们需要在软件开发界得到更多的认可。我正在计划发布更多的有关于 websockets 的文章。如果你不想错过这些文章，你可以访问 <a href="https://nooptoday.com/">https://nooptoday.com/</a> 并且订阅我的邮箱列表！</p></blockquote><hr><h2 id="是什么让-Websockets-如此独一无二"><a href="#是什么让-Websockets-如此独一无二" class="headerlink" title="是什么让 Websockets 如此独一无二?"></a><a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267#what-makes-websockets-unique"></a>是什么让 Websockets 如此独一无二?</h2><p>Websocket 是一个应用层的协议，就像 HTTP 是另外一个应用层的协议一样。这两个协议都是通过 TCP 连接实现的。但是他们有不同特点，就像他们代表着通信世界的两个不同国家（如果这样形容能让你理解的话）。</p><p>HTTP 带有基于请求—响应的通信模型的标志，Websocket 带有双向通信模型的标志。</p><blockquote><p>附注：为了更清晰地描述 Websocket，你将在文章中看到 HTTP 和 Websocket 的对比。但这并不意味着它们是相互竞争的协议，相反，它们都有自己的用例。</p></blockquote><p><strong>Websocket 的特点：</strong></p><ul><li>双向通信</li><li>长期的 TCP 连接</li><li>有状态的协议</li></ul><p><strong>HTTP 的特点：</strong></p><ul><li>基于请求响应的通信</li><li>短期的 TCP 连接</li><li>无状态的协议</li></ul><h3 id="有状态-vs-无状态协议"><a href="#有状态-vs-无状态协议" class="headerlink" title="有状态 vs. 无状态协议"></a><a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267#stateful-vs-stateless-protocols"></a>有状态 vs. 无状态协议</h3><p>我相信你看过一些关于创建无状态、可无限扩展的后端服务器的文章。这些文章会告诉你使用 JWT 令牌进行无状态的身份验证，并在无状态应用程序中使用 lambda 函数等。</p><ul><li>这些文章所谈论的<strong>状态</strong>是什么？当涉及到扩展服务器应用程序时，为什么它如此重要？</li></ul><p><strong>状态</strong>是你的应用程序为了正确运行所必须记住的所有信息。例如，你的应用程序应该记住已经登录的用户。99% 的应用程序都这么做并且它被成为会话管理。</p><ul><li>OK，状态真是一个很好的东西！那为什么人们讨厌它并且总是试图做出<strong>无状态的应用</strong>呢？</li></ul><p>你需要在某些地方存储你的状态，而那个地方通常是服务器的内存。但是你的应用服务器的内存对于其他服务器来说是不可访问的，那么问题就来了。</p><p>想象这样一个场景：</p><ul><li><strong>用户 A</strong> 向<strong>服务器 1</strong> 发起请求。<strong>服务器 1</strong> 授权给<strong>用户 A</strong>，接着在内存中存储它的<strong>会话 A</strong>。</li><li><strong>用户 A</strong> 向<strong>服务器 2</strong> 发起第二个请求。<strong>服务器 2</strong> 搜索保存的会话，但是无法找到<strong>会话 A</strong>，因为它被存储在<strong>服务器 1</strong> 内部。</li></ul><p>为了让你的服务器变得可扩展，你需要在应用程序之外管理状态。例如，你可以将会话保存到 Redis 实例中。这使得应用程序状态可以通过 Redis 对所有服务器可用，并且<strong>服务器 2</strong> 可以从 Redis 读取<strong>会话 A</strong>。</p><hr><p><strong>有状态的 Websocket：</strong> 打开 Websocket 连接就像客户端和服务器之间的婚礼：连接一直保持打开状态，直到其中一方关闭它（当然，或者由于网络条件欺骗它）。</p><p><strong>无状态的 HTTP：</strong> 另一方面，HTTP 是一个令人心碎的协议，它希望尽快结束所有事情。打开 HTTP 连接后，客户端发送请求，服务器一响应，连接就会关闭。</p><p>OK，我不开玩笑了，但是记住，Websocket 连接<strong>通常</strong>是长连接，而 HTTP 连接注定是尽早结束的。当你把 Websocket 引入到你的应用程序时，它就变成了<strong>有状态的</strong>。</p><h4 id="如果你想知道"><a href="#如果你想知道" class="headerlink" title="如果你想知道"></a><a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267#in-case-you-wonder"></a>如果你想知道</h4><p>尽管 HTTP 和 Websocket 都构建在 TCP 之上，但一个是无状态的，而另一个是有状态的。为了简单起见，我不想让你对 TCP 的细节感到困惑。但是请记住，即使在 HTTP 中，底层 TCP 连接也可能存在很长时间。这超出了本文的范围，但你可以在<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">这里</a>学到更多。</p><h3 id="我不能只使用一个-Redis-实例来存储套接字吗？"><a href="#我不能只使用一个-Redis-实例来存储套接字吗？" class="headerlink" title="我不能只使用一个 Redis 实例来存储套接字吗？"></a><a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267#cant-i-just-use-a-redis-instance-to-store-sockets"></a>我不能只使用一个 Redis 实例来存储套接字吗？</h3><p>在上一个有关会话的例子中，其解决方法很简单。使用外部服务来存储会话，这样其他所有服务器都可以从那里读取会话（Redis 实例）。</p><p>Websockets 是一个不同的例子，因为你的状态不仅仅是关于套接字的数据，所以不可避免地要在服务器中存储<strong>连接</strong>。每个 websocket 连接都绑定到一台服务器上，其他服务器无法向该连接发送数据。</p><p>现在，第二个问题来了，你必须有一种方法让其他服务器发送消息到 websocket 连接。为此，您需要一种在服务器之间发送消息的方法。幸运的是，这已经有一个称为<strong>消息代理</strong>的东西。你甚至可以使用 Redis 的发布&#x2F;订阅机制在你的服务器之间发送消息。</p><p>让我们总结一下目前为止我们讨论的内容：</p><ul><li>Websocket 连接是有状态的</li><li>Websocket 服务器自动成为有状态的应用程序</li><li>为了使有状态应用程序能够扩展，您需要有一个外部状态存储（例如：Redis）</li><li>Websocket 连接绑定到单个服务器</li><li>服务器需要连接到消息代理，将消息发送到其他服务器中的 websockets</li></ul><p>（就这样吗？添加一个 Redis 实例到我的堆栈就可以解决了所有的 Websockets可伸缩的问题？）</p><p>不幸的是，不是的。好吧，可伸缩的 websocket 架构还有另一个问题：<strong>负载均衡</strong></p><h3 id="Websockets-的负载均衡"><a href="#Websockets-的负载均衡" class="headerlink" title="Websockets 的负载均衡"></a><a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267#load-balancing-websockets"></a>Websockets 的负载均衡</h3><p>负载均衡是确保所有服务器共享同等负载的一项技术。在普通的 HTTP 服务器中，这可以通过简单的算法例如轮询来实现。但这对于 Websocket 服务器来说并不理想。</p><p>想象一下你拥有一个自动伸缩的服务器组，这意味着，随着负载的增加，新的实例将会被部署，而随着负载的减少，一些实例将被关闭。</p><p>因为 HTTP 请求的生存时间很短，因此即使添加或删除服务器，所有实例之间的负载也会均衡一些。</p><p>Websocket 连接的生存时间很长（持久的），这意味着新服务器不会从旧服务器上减轻负载。因为，旧服务器仍然坚持它们的 websocket 连接。举个例子，假设<strong>服务器 1</strong> 拥有 1000 个开放的 websocket 连接。理想情况下，当添加一个新的服务器<strong>服务器 2</strong> 时，你希望将 500 个 websocket 连接从<strong>服务器 1</strong> 转移到<strong>服务器 2</strong>。但这对于传统的负载平衡器来说是不可能的。</p><p>你可以断开所有的 websocket 连接，并期望客户端重新连接。然后你就可以在你的服务器上实现 500 &#x2F; 500 个 websocket 连接的分布方案，但这是一个糟糕的解决方案，因为：</p><ol><li>服务器将受到重连接请求的狂轰滥炸，服务器负载将大幅波动</li><li>如果频繁地扩展服务器，客户端将频繁地重新连接，这可能会对用户体验产生负面影响</li><li>这不是一个优雅的解决方案，（我知道你们关心这个！）</li></ol><p>这个问题最优雅的解决方法被称为：一致性哈希</p><h2 id="负载均衡算法：一致性哈希"><a href="#负载均衡算法：一致性哈希" class="headerlink" title="负载均衡算法：一致性哈希"></a><a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267#load-balancing-algorithm-consistent-hashing"></a>负载均衡算法：一致性哈希</h2><p>如今有各种各样的负载均衡算法，但一致性哈希来自另一个世界。（图片白纸上的内容译为“一致性哈希真的很棒！请改变我的这个想法。”）<br><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--5P8luiyt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://nooptoday.com/content/images/2022/12/image-1.png"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5P8luiyt--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://nooptoday.com/content/images/2022/12/image-1.png" alt="meme about consistent hashing"></a><br>使用一致性哈希的负载均衡背后的基本思想是：</p><ul><li>对即将到来并带有某些属性的连接进行哈希操作，就比如<strong>用户 ID &#x3D;&gt; 哈希值</strong></li><li>然后你可以用<strong>哈希值</strong>来确定该用户应该连接到哪个服务器</li></ul><p>这里假设你的哈希函数将<strong>用户 ID</strong> 均匀分配到<strong>哈希值</strong>。</p><p>但是！总是有一个但是，不是吗？现在在添加或删除服务器时仍然存在这个问题。解决方案是在添加或删除新服务器时断开连接。</p><p>（等一下，什么！你刚刚还说这个一个坏主意？现在怎么又变成了解决方案了呢？）</p><p>这个解决方案的美妙之处在于，使用一致性哈希，你不必断开所有连接，而只需删除部分连接。实际上，你需要断开多少连接就断开多少连接。让我用一个场景来解释：</p><ul><li>最开始， <strong>服务器 1</strong> 有 1000 个连接</li><li>新增<strong>服务器 2</strong></li><li>一旦新增了<strong>服务器 2</strong>，<strong>服务器 1</strong> 就会运行重新平衡算法</li><li>重新平衡算法检测哪些 websocket 连接需要断开，如果我们的哈希函数检测到大约 500 个连接需要到<strong>服务器 2</strong></li><li><strong>服务器 1</strong> 向这 500 个客户端发出重新连接消息，然后它们连接到<strong>服务器 2</strong>。</li></ul><p><a href="https://www.youtube.com/watch?v=UF9Iqmg94tk">这是ByteByteGo的一个很棒的视频</a>，这个视频从视觉上解释了这个概念。</p><h3 id="一个更简单且高效的解决办法"><a href="#一个更简单且高效的解决办法" class="headerlink" title="一个更简单且高效的解决办法"></a><a href="https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267#a-much-simpler-and-efficient-solution"></a>一个更简单且高效的解决办法</h3><p>Discord 管理大量 Websocket 连接。他们是如何解决负载均衡的问题？</p><p>如果你研究了<a href="https://discord.com/developers/docs/topics/gateway#get-gateway">开发者文档</a>关于如何建立 websocket 连接，下面是他们是如何做到的：</p><ul><li>发送一个 HTTP 的 GET 请求到  <code>/gateway</code> 端点，接收可用的 Websocket 服务器 url。</li><li>连接到 Websocket 服务器。</li></ul><p>这个解决方案的神奇之处在于，你可以控制新客户端应该连接哪台服务器。如果添加新服务器，则可以将所有新连接定向到新服务器。如果你想将 500 个连接从<strong>服务器 1</strong> 移动到<strong>服务器 2</strong>，只需从<strong>服务器 1</strong> 删除500个连接，并从 <code>/gateway</code> 端点提供<strong>服务器 2</strong> 地址。</p><p><code>/gateway</code> 端点需要知道所有服务器的负载分布，并据此做出决策。以最小的负载直接返回服务器的 url。</p><p>与一致散列相比，这种解决方案有效且简单得多。但是，一致哈希方法不需要知道所有服务器的负载分布，也不需要事先进行 HTTP 请求。因此，客户端可以更快地连接，但这通常不是一个重要的考虑因素。此外，实现一致的哈希算法也很棘手。这就是为什么，我计划后续写一篇关于为负载均衡 Websockets 实现一致性哈希的文章。</p><p>我希望你能从这篇文章中学到一些新的东西，请在评论中告诉我你的想法。如果你不想错过新的文章，你可以订阅邮件列表！</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原文地址：&lt;a href=&quot;https://dev.to/nooptoday/why-websockets-are-hard-to-scale-1267&quot;&gt;why Websockets are Hard To Scale？&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    <category term="掘金翻译计划" scheme="https://itcodes.github.io/categories/%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
    
    <category term="掘金翻译计划" scheme="https://itcodes.github.io/tags/%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>OpenAI 推出超神 ChatGPT 注册攻略来了</title>
    <link href="https://itcodes.github.io/d744d1d3d1e8/"/>
    <id>https://itcodes.github.io/d744d1d3d1e8/</id>
    <published>2023-02-06T07:58:31.000Z</published>
    <updated>2025-09-07T16:26:41.667Z</updated>
    
    <content type="html"><![CDATA[<p>前几天，OpenAI 推出超神 ChatGPT，非常火爆。但是呢，因为不可抗力原因，大部分人无法体验到。这里我分享一下注册的攻略。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>首先能能访问 Google（前置条件，不能明确说，懂得都懂）</li><li>你得有一个国外手机号，GV 号肯定不行。<ul><li>如果你没有国外手机号，推荐sms-activate.org</li></ul></li></ul><h3 id="注册短信平台并充值"><a href="#注册短信平台并充值" class="headerlink" title="注册短信平台并充值"></a>注册短信平台并充值</h3><ul><li>先行注册sms-activate.org</li><li>注册好之后进行对应的充值</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8acaf6d767714b1d82122cd3206f4ba7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>接码费用一次为 10.5 卢布，大约1.2 人民币。因为充值默认为美元，可以选择充值 1 美元进去，</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c507b1564d1442d8dfab0ebc8d481e1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="注册OpenAI账号"><a href="#注册OpenAI账号" class="headerlink" title="注册OpenAI账号"></a>注册OpenAI账号</h3><ul><li>打开<a href="https://beta.openai.com/signup">https://beta.openai.com/signup</a> 页面进行相应的注册。<ul><li>这里同样需要你能访问Google且 ip 不是香港，最好是美国、新加坡等等，不然会提示不能在当前国家服务。</li></ul></li><li>注册成功进入下面填写手机号的页面<ul><li>下面记得切换下国家区号，这里的区号默认是你代理的。</li></ul></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d50d22c04df0430aa0b2afca70a55beb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="准备接码"><a href="#准备接码" class="headerlink" title="准备接码"></a>准备接码</h3><blockquote><p>这里需要注意下的就是，目前好像就只有巴西和印度支持了，之前我选的印尼，是可以收到码的。</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79235be8d7104175a6dda1cc63f46937~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2e4434858ab4cbaaa9e1d8249305547~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li>然后再刚刚填写手机号码的页面填入申请的手机号</li></ul><h3 id="开始使用ChatGPT"><a href="#开始使用ChatGPT" class="headerlink" title="开始使用ChatGPT"></a>开始使用ChatGPT</h3><p>注册完后，我们去ChatGPT网站去登陆。<a href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e474b55d15d4b8ea3c56e7deb5ce8f9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf36cc1afc9b45539f543211739c9f83~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="12-月-6-日更新"><a href="#12-月-6-日更新" class="headerlink" title="12 月 6 日更新"></a>12 月 6 日更新</h4><ul><li>如果你的页面出现下面提示，说明你代理不行~~</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc290c2a7abf4c9faee9a392819d16e4~tplv-k3u1fbpfcp-watermark.image" alt="img_v2_36533eb4-fa66-40bb-b165-ad8b6d401d2g.jpg"></p><ul><li>接不到码，可以在那个有效期内退回换个号试试。<ul><li>有人直接把发的电话输入框里，没去掉区号也可以收到</li></ul></li><li>这个接码网站很全面，我演示充值是 1 美元，你也可以冲一个 0.18美元</li><li>目前完全支持的是印度+巴西。你也可以选择其他国家的 any+other 选择合适的费用即可。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前几天，OpenAI 推出超神 ChatGPT，非常火爆。但是呢，因为不可抗力原因，大部分人无法体验到。这里我分享一下注册的攻略。&lt;/p&gt;
&lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;</summary>
      
    
    
    
    <category term="人工智能" scheme="https://itcodes.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="OPenAI" scheme="https://itcodes.github.io/tags/OPenAI/"/>
    
    <category term="Chatgpt" scheme="https://itcodes.github.io/tags/Chatgpt/"/>
    
  </entry>
  
</feed>
